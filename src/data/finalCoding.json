[
    {
        "id": 1,
        "title": "AETHER CORE RECOVERY",
        "description": "The Final System Core is locked. You have collected a list of IDs and Corrupted Strings from the previous phases. You must process them through 5 specific phases to generate the Final Override Key.",
        "inputDescription": "IDs: [13, 4, 7, 10, 6, 11, 8, 9, 2]\nStrings: ['Chaos@@', 'Al%#pha', 'Pri!!me', 'Gam+ma', 'Be--ta', 'Zeus!!', 'Ome--ga', 'Del@@ta', 'Roo#t']",
        "expectedOutput": "tfnuf",
        "boilerplateC": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include <ctype.h>\n\n// --- PHASE 1: FILTER ---\n// Remove entries where ID is a PRIME number.\n// Returns new count of items.\nint phase_1_filter(int ids[], char strs[][50], int count, int out_ids[], char out_strs[][50]) {\n    // Write logic here\n    return 0;\n}\n\n// --- PHASE 2: SANITIZE ---\n// Keep only Alphanumeric characters in strings.\nvoid phase_2_sanitize(char strs[][50], int count) {\n    // Write logic here\n}\n\n// --- PHASE 3: SORT ---\n// 1. Sort by String Length (Descending)\n// 2. If lengths are equal, Sort by ID (Ascending)\nvoid phase_3_sort(int ids[], char strs[][50], int count) {\n    // Write logic here\n}\n\n// --- PHASE 4: FORGE ---\n// Extract the middle character of each string to form a key.\nvoid phase_4_forge(char strs[][50], int count, char outputKey[]) {\n    // Write logic here\n}\n\n// --- PHASE 5: ENCRYPT ---\n// Shift every character in key by +1 (a->b, z->a)\nvoid phase_5_encrypt(char key[], char finalKey[]) {\n    // Write logic here\n}\n\nint main() {\n    int ids[] = { 13, 4, 7, 10, 6, 11, 8, 9, 2 };\n    char strs[][50] = {\n        \"Chaos@@\", \"Al%#pha\", \"Pri!!me\", \"Gam+ma\", \n        \"Be--ta\", \"Zeus!!\", \"Ome--ga\", \"Del@@ta\", \"Roo#t\"\n    };\n    int count = 9;\n\n    int valid_ids[10];\n    char valid_strs[10][50];\n    char raw_key[100] = \"\", final_key[100] = \"\";\n\n    printf(\"--- AETHER_OS RECOVERY ---\\n\");\n\n    count = phase_1_filter(ids, strs, count, valid_ids, valid_strs);\n    printf(\"Phase 1 Count: %d\\n\", count);\n\n    phase_2_sanitize(valid_strs, count);\n    phase_3_sort(valid_ids, valid_strs, count);\n    phase_4_forge(valid_strs, count, raw_key);\n    phase_5_encrypt(raw_key, final_key);\n\n    printf(\"FINAL KEY: %s\\n\", final_key);\n\n    return 0;\n}",
        "boilerplatePython": "def is_prime(n):\n    if n <= 1: return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0: return False\n    return True\n\ndef recover_system():\n    ids = [13, 4, 7, 10, 6, 11, 8, 9, 2]\n    strs = [\"Chaos@@\", \"Al%#pha\", \"Pri!!me\", \"Gam+ma\", \"Be--ta\", \"Zeus!!\", \"Ome--ga\", \"Del@@ta\", \"Roo#t\"]\n    \n    # --- PHASE 1: FILTER (Remove Primes) ---\n    # Your logic here\n    \n    # --- PHASE 2: SANITIZE (Keep Alphanumeric) ---\n    # Your logic here\n    \n    # --- PHASE 3: SORT ---\n    # 1. Length Descending\n    # 2. ID Ascending\n    # Your logic here\n    \n    # --- PHASE 4: FORGE (Middle Char) ---\n    # Your logic here\n    \n    # --- PHASE 5: ENCRYPT (+1 Shift) ---\n    # Your logic here\n    \n    final_key = \"\" # Replace with result\n    print(f\"FINAL KEY: {final_key}\")\n\nif __name__ == \"__main__\":\n    recover_system()",
        "solutionC": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include <ctype.h>\n\n// Helper for Bubble Sort logic\nvoid helper_sort(int ids[], char strs[][50], int count) {\n    for (int i = 0; i < count - 1; i++) {\n        for (int j = 0; j < count - i - 1; j++) {\n            int len1 = strlen(strs[j]);\n            int len2 = strlen(strs[j+1]);\n            int swap = 0;\n\n            if (len2 > len1) { // Descending Length\n                swap = 1;\n            }\n            else if (len1 == len2) {\n                if (ids[j] > ids[j+1]) { // Ascending ID\n                    swap = 1;\n                }\n            }\n\n            if (swap) {\n                char temp_str[50];\n                strcpy(temp_str, strs[j]);\n                strcpy(strs[j], strs[j+1]);\n                strcpy(strs[j+1], temp_str);\n\n                int temp_id = ids[j];\n                ids[j] = ids[j+1];\n                ids[j+1] = temp_id;\n            }\n        }\n    }\n}\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nint main() {\n    int n = 9;\n    int ids[] = {13, 4, 7, 10, 6, 11, 8, 9, 2};\n    char strs[][50] = {\"Chaos@@\", \"Al%#pha\", \"Pri!!me\", \"Gam+ma\", \"Be--ta\", \"Zeus!!\", \"Ome--ga\", \"Del@@ta\", \"Roo#t\"};\n\n    int new_ids[20];\n    char new_strs[20][50];\n    int j = 0;\n\n    // Phase 1\n    for (int i = 0; i < n; i++) {\n        if (!is_prime(ids[i])) {\n            new_ids[j] = ids[i];\n            strcpy(new_strs[j], strs[i]);\n            j++;\n        }\n    }\n\n    // Phase 2\n    for (int i = 0; i < j; i++) {\n        char clean_str[50];\n        int p = 0;\n        for (int k = 0; new_strs[i][k] != '\\0'; k++) {\n            if (isalnum(new_strs[i][k])) {\n                clean_str[p] = new_strs[i][k];\n                p++;\n            }\n        }\n        clean_str[p] = '\\0';\n        strcpy(new_strs[i], clean_str);\n    }\n\n    // Phase 3\n    helper_sort(new_ids, new_strs, j);\n\n    // Phase 4 & 5\n    char final_key[50] = \"\";\n    for (int i = 0; i < j; i++) {\n        int l = strlen(new_strs[i]) / 2;\n        char c = new_strs[i][l];\n        \n        // Encrypt\n        if (c == 'z') c = 'a';\n        else c = c + 1;\n        \n        strncat(final_key, &c, 1);\n    }\n\n    printf(\"FINAL KEY: %s\", final_key);\n    return 0;\n}",
        "solutionPython": "def is_prime(n):\n    if n <= 1: return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0: return False\n    return True\n\ndef recover_system():\n    ids = [13, 4, 7, 10, 6, 11, 8, 9, 2]\n    strs = [\"Chaos@@\", \"Al%#pha\", \"Pri!!me\", \"Gam+ma\", \"Be--ta\", \"Zeus!!\", \"Ome--ga\", \"Del@@ta\", \"Roo#t\"]\n    \n    # Phase 1: Filter\n    filtered_data = []\n    for i in range(len(ids)): \n        if not is_prime(ids[i]):\n            filtered_data.append({'id': ids[i], 's': strs[i]})\n            \n    # Phase 2: Sanitize\n    for item in filtered_data:\n        item['s'] = ''.join(c for c in item['s'] if c.isalnum())\n        \n    # Phase 3: Sort (Length Desc, ID Asc)\n    # Note: Python Sort is stable. We sort by ID first (Asc), then Length (Desc)\n    filtered_data.sort(key=lambda x: x['id']) # Ascending ID\n    filtered_data.sort(key=lambda x: len(x['s']), reverse=True) # Descending Length\n    \n    # Phase 4 & 5: Forge & Encrypt\n    final_key = \"\"\n    for item in filtered_data:\n        s = item['s']\n        mid = len(s) // 2\n        char = s[mid]\n        \n        # Shift\n        if char == 'z': new_char = 'a'\n        else: new_char = chr(ord(char) + 1)\n        final_key += new_char\n        \n    print(f\"FINAL KEY: {final_key}\")\n\nif __name__ == \"__main__\":\n    recover_system()"
    }
]