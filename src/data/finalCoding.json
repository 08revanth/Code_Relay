[
    {
        "id": 1,
        "title": "AETHER CORE RECOVERY",
        "description": "Attention Tech Rangers! This is AetherOS Core. We have stabilized the peripheral sectors. The Security Watcher, the Thermal Bridge, and the Transit Grid are back online. But the Master Timeline remains fractured.\n\nThe data you collected is useless in isolation. The Command Center holds the logic, but the Field Agents hold the keys. The Shadow Byte virus has scrambled the final recovery protocol to prevent a single unit from solving it.\n\nWe are initiating Protocol: UNITY. All Field Agents: Abandon your sectors. All Command Units: Lock your terminals. CONVERGE AT THE AUDITORIUM IMMEDIATELY. You have 9 Fragments of a broken instruction and 9 Slices of corrupted data. Only together can you forge the Master Key.\n\nBring your physical notes. Bring your digital logs.",
        "inputDescription": "IDs: [13, 4, 7, 10, 6, 11, 8, 9, 2]\nStrings: ['Chaos@@', 'Al%#pha', 'Pri!!me', 'Gam+ma', 'Be--ta', 'Zeus!!', 'Ome--ga', 'Del@@ta', 'Roo#t']",
        "expectedOutput": "pelmt",
        "boilerplateC": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\n// ==========================================\n// HELPER FUNCTIONS (To be Implemented by Solver)\n// ==========================================\n\n// Phase 1 Instruction: Implement the prime check logic here.\nbool is_prime(int n) {\n    // Implement function to check prime number here.\n    return false;\n}\n\n// Helper Sort Function (For Phase 3)\nvoid helper_sort(int ids[], char strs[][50], int count) {\n    for (int i = 0; i < count - 1; i++) {\n        for (int j = 0; j < count - i - 1; j++) {\n            int len1 = strlen(strs[j]);\n            int len2 = strlen(strs[j+1]);\n            int swap = 0;\n\n            if (len2 > len1) {\n                swap = 1;\n            } else if (len1 == len2) {\n                if (ids[j] > ids[j+1]) {\n                    swap = 1;\n                }\n            }\n\n            if (swap) {\n                char temp_str[50];\n                strcpy(temp_str, strs[j]);\n                strcpy(strs[j], strs[j+1]);\n                strcpy(strs[j+1], temp_str);\n\n                int temp_id = ids[j];\n                ids[j] = ids[j+1];\n                ids[j+1] = temp_id;\n            }\n        }\n    }\n    printf(\"[SYSTEM] Helper Sort Applied.\\n\");\n}\n\n// ==========================================\n// PHASE FUNCTIONS (To be Implemented by Solver)\n// ==========================================\n\n// Phase 1: Filter Primes -> Store in new buffers\n// Instruction: Call is_prime(id) and copy non-prime entries to new_ids/new_strs.\nint phase_1_filter(int old_ids[], char old_strs[][50], int count, int new_ids[], char new_strs[][50]) {\n    int j = 0;\n    for (int i = 0; i < count; i++) {\n        // Call the implemented helper function\n        if (!is_prime(old_ids[i])) {\n            new_ids[j] = old_ids[i];\n            strcpy(new_strs[j], old_strs[i]);\n            j++;\n        }\n    }\n    return j;\n}\n\n// Phase 2: Sanitize Strings -> Remove symbols in place\n// Instruction: Remove non-alphanumeric characters from 'strs' in place.\nvoid phase_2_sanitize(char strs[][50], int count) {\n    // TODO: Write Sanitize Logic\n}\n\n// Phase 3: Sort\n// Instruction: Sort by Length (Desc), then ID (Asc).\n// HINT: Call helper_sort(ids, strs, count) found at the bottom of the file.\nvoid phase_3_sort(int ids[], char strs[][50], int count) {\n    // TODO: Call the helper function\n}\n\n// Phase 4: Forge Key -> Extract middle char\n// Instruction: Extract the character at 'Length / 2' from each string.\nvoid phase_4_forge(char strs[][50], int count, char *raw_key) {\n    // TODO: Extract characters\n    raw_key[0] = '\\0';\n}\n\n// ==========================================\n// MAIN EXECUTION\n// ==========================================\nint main() {\n    int n = 9;\n    \n    // Initial Input Data\n    int ids[] = {13, 4, 7, 10, 6, 11, 8, 9, 2};\n    char strs[][50] = {\n        \"Chaos@@\", \"Al%#pha\", \"Pri!!me\", \"Gam+ma\", \n        \"Be--ta\", \"Zeus!!\", \"Ome--ga\", \"Del@@ta\", \"Roo#t\"\n    };\n\n    // Output Buffers\n    int new_ids[20];\n    char new_strs[20][50];\n    char raw_key[20];\n\n    printf(\"--- AETHER_OS PROTOCOL STARTED ---\\n\");\n\n    // --- EXECUTE PHASE 1 ---\n    int valid_count = phase_1_filter(ids, strs, n, new_ids, new_strs);\n    \n    printf(\"Phase 1 Output (%d items).\\n\", valid_count);\n\n    // --- EXECUTE PHASE 2 ---\n    phase_2_sanitize(new_strs, valid_count);\n    \n    printf(\"Phase 2 Output (Sanitized).\\n\");\n\n    // --- EXECUTE PHASE 3 ---\n    phase_3_sort(new_ids, new_strs, valid_count);\n    \n    printf(\"Phase 3 Output (Sorted).\\n\");\n\n    // --- EXECUTE PHASE 4 ---\n    phase_4_forge(new_strs, valid_count, raw_key);\n    printf(\"\\nPhase 4 Raw Key: %s\\n\", raw_key);\n\n    printf(\"FINAL PASSWORD: %s\\n\", raw_key); \n\n    return 0;\n}",
        "boilerplatePython": "import re\nimport math\nimport copy\n\n# ==========================================\n# HELPER FUNCTIONS\n# ==========================================\n# Check if a number is Prime\ndef is_prime(n):\n    # Implement Prime Check\n    return False\n\n# Helper Sort Function (For Phase 3)\ndef helper_sort(ids, strs):\n    # This function is pre-implemented for the solver's convenience.\n    combined = list(zip(ids, strs))\n    combined.sort(key=lambda x: (-len(x[1]), x[0]))\n    sorted_ids, sorted_strs = zip(*combined)\n    \n    # Note: Python functions must return the new lists for reassignment in main.\n    print(\"[SYSTEM] Helper Sort Applied.\")\n    return list(sorted_ids), list(sorted_strs)\n\n# ==========================================\n# PHASE FUNCTIONS\n# ==========================================\n# Phase 1: Filter Primes -> Store in new buffers\n# Instruction: Call is_prime(id) and copy non-prime entries to new_ids/new_strs.\ndef phase_1_filter(old_ids, old_strs):\n    new_ids = []\n    new_strs = []\n    \n    for i in range(len(old_ids)):\n        # Call the implemented helper function\n        if not is_prime(old_ids[i]):\n            new_ids.append(old_ids[i])\n            new_strs.append(old_strs[i])\n            \n    return new_ids, new_strs\n\n# Phase 2: Sanitize Strings -> Remove symbols in place\n# Instruction: Remove non-alphanumeric characters from 'strs' in place.\ndef phase_2_sanitize(ids, strs):\n    # TODO: Write Sanitize Logic\n    # Solvers must write the logic to clean the strings.\n    return ids, strs # Returning input arrays as stubs\n\n# Phase 3: Sort\n# Instruction: Sort by Length (Desc), then ID (Asc).\ndef phase_3_sort(ids, strs):\n    # The solution for this phase is to call the helper function provided below.\n    return ids, strs\n\n# Phase 4: Forge Key -> Extract middle char\n# Instruction: Extract the character at 'Length / 2' from each string.\ndef phase_4_forge(strs, count):\n    # TODO: Write Forge Logic\n    return \"\" \n\n# ==========================================\n# MAIN EXECUTION\n# ==========================================\ndef main():\n    n = 9\n    \n    # Initial Input Data\n    ids = [13, 4, 7, 10, 6, 11, 8, 9, 2]\n    strs = [\n        \"Chaos@@\", \"Al%#pha\", \"Pri!!me\", \"Gam+ma\", \n        \"Be--ta\", \"Zeus!!\", \"Ome--ga\", \"Del@@ta\", \"Roo#t\"\n    ]\n    \n    print(\"--- AETHER_OS PROTOCOL STARTED ---\")\n    \n    # --- EXECUTE PHASE 1 ---\n    ids, strs = phase_1_filter(ids, strs)\n    valid_count = len(ids)\n    print(f\"Phase 1 Output ({valid_count} items).\")\n    \n    # --- EXECUTE PHASE 2 ---\n    ids, strs = phase_2_sanitize(ids, strs)\n    print(\"Phase 2 Output (Sanitized).\")\n    \n    # --- EXECUTE PHASE 3 ---\n    ids, strs = phase_3_sort(ids, strs)\n    print(\"Phase 3 Output (Sorted).\")\n    \n    # --- EXECUTE PHASE 4 ---\n    final_sequence = phase_4_forge(strs, valid_count)\n    \n    # --- OUTPUT ---\n    print(f\"\\nRaw Key (Decoded Sequence): {final_sequence}\")\n    \n    # FINAL ANSWER (for verification)\n    print(f\"FINAL PASSWORD: {final_sequence}\") \n    return 0\n\nif __name__ == \"__main__\":\n    main()",
        "solutionC": "#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\nvoid helper_sort(int ids[], char strs[][50], int count);\n\nbool is_prime(int n) {\n    if (n <= 1) return false;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n\nvoid helper_sort(int ids[], char strs[][50], int count) {\n    for (int i = 0; i < count - 1; i++) {\n        for (int j = 0; j < count - i - 1; j++) {\n            int len1 = strlen(strs[j]);\n            int len2 = strlen(strs[j+1]);\n            int swap = 0;\n            if (len2 > len1) {\n                swap = 1;\n            } else if (len1 == len2) {\n                if (ids[j] > ids[j+1]) {\n                    swap = 1;\n                }\n            }\n            if (swap) {\n                char temp_str[50];\n                strcpy(temp_str, strs[j]);\n                strcpy(strs[j], strs[j+1]);\n                strcpy(strs[j+1], temp_str);\n                int temp_id = ids[j];\n                ids[j] = ids[j+1];\n                ids[j+1] = temp_id;\n            }\n        }\n    }\n    printf(\"[SYSTEM] Helper Sort Applied.\\n\");\n}\n\nint phase_1_filter(int old_ids[], char old_strs[][50], int count, int new_ids[], char new_strs[][50]) {\n    int j = 0;\n    for (int i = 0; i < count; i++) {\n        if (!is_prime(old_ids[i])) { \n            new_ids[j] = old_ids[i];\n            strcpy(new_strs[j], old_strs[i]);\n            j++;\n        }\n    }\n    return j;\n}\n\nvoid phase_2_sanitize(char strs[][50], int count) {\n    for (int i = 0; i < count; i++) {\n        char clean_str[50];\n        int p = 0;\n        for (int k = 0; strs[i][k] != '\\0'; k++) {\n            if (isalnum(strs[i][k])) {\n                clean_str[p] = strs[i][k];\n                p++;\n            }\n        }\n        clean_str[p] = '\\0';\n        strcpy(strs[i], clean_str);\n    }\n}\n\nvoid phase_3_sort(int ids[], char strs[][50], int count) {\n    helper_sort(ids, strs, count);\n}\n\nvoid phase_4_forge(char strs[][50], int count, char *raw_key) {\n    for (int i = 0; i < count; i++) {\n        int l = strlen(strs[i]) / 2;\n        raw_key[i] = strs[i][l];\n    }\n    raw_key[count] = '\\0';\n}\n\nint main() {\n    int n = 9;\n    int ids[] = {13, 4, 7, 10, 6, 11, 8, 9, 2};\n    char strs[][50] = {\n        \"Chaos@@\", \"Al%#pha\", \"Pri!!me\", \"Gam+ma\", \n        \"Be--ta\", \"Zeus!!\", \"Ome--ga\", \"Del@@ta\", \"Roo#t\"\n    };\n    int new_ids[20];\n    char new_strs[20][50];\n    char raw_key[20];\n    printf(\"--- AETHER_OS PROTOCOL STARTED ---\\n\");\n    int valid_count = phase_1_filter(ids, strs, n, new_ids, new_strs);\n    printf(\"Phase 1 Output (%d items).\\n\", valid_count);\n    phase_2_sanitize(new_strs, valid_count);\n    printf(\"Phase 2 Output (Sanitized).\\n\");\n    phase_3_sort(new_ids, new_strs, valid_count);\n    printf(\"Phase 3 Output (Sorted).\\n\");\n    phase_4_forge(new_strs, valid_count, raw_key);\n    printf(\"\\nRaw Key: %s\\n\", raw_key);\n    printf(\"FINAL PASSWORD: %s\\n\", raw_key); \n    return 0;\n}",
        "solutionPython": "import re\nimport math\nimport copy\n\ndef is_prime(n):\n    if n <= 1: return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0: return False\n    return True\n\ndef helper_sort(ids, strs):\n    combined = list(zip(ids, strs))\n    combined.sort(key=lambda x: (-len(x[1]), x[0]))\n    sorted_ids, sorted_strs = zip(*combined)\n    print(\"[SYSTEM] Helper Sort Applied.\")\n    return list(sorted_ids), list(sorted_strs)\n\ndef phase_1_filter(old_ids, old_strs):\n    new_ids = []\n    new_strs = []\n    for i in range(len(old_ids)):\n        if not is_prime(old_ids[i]):\n            new_ids.append(old_ids[i])\n            new_strs.append(old_strs[i])\n    return new_ids, new_strs\n\ndef phase_2_sanitize(ids, strs):\n    new_strs_sanitized = []\n    for s in strs:\n        clean_str = \"\".join(c for c in s if c.isalnum())\n        new_strs_sanitized.append(clean_str)\n    return ids, new_strs_sanitized\n\ndef phase_3_sort(ids, strs):\n    return helper_sort(ids, strs)\n\ndef phase_4_forge(strs, count):\n    raw_key = \"\"\n    for i in range(count):\n        s = strs[i]\n        l = len(s) // 2\n        raw_key += s[l]\n    return raw_key\n\ndef main():\n    n = 9\n    ids = [13, 4, 7, 10, 6, 11, 8, 9, 2]\n    strs = [\"Chaos@@\", \"Al%#pha\", \"Pri!!me\", \"Gam+ma\", \"Be--ta\", \"Zeus!!\", \"Ome--ga\", \"Del@@ta\", \"Roo#t\"]\n    print(\"--- AETHER_OS PROTOCOL STARTED ---\")\n    ids, strs = phase_1_filter(ids, strs)\n    valid_count = len(ids)\n    print(f\"Phase 1 Output ({valid_count} items).\")\n    ids, strs = phase_2_sanitize(ids, strs)\n    print(\"Phase 2 Output (Sanitized).\")\n    ids, strs = phase_3_sort(ids, strs)\n    print(\"Phase 3 Output (Sorted).\")\n    final_password = phase_4_forge(strs, valid_count)\n    print(f\"\\nRaw Key: {final_password}\")\n    print(f\"FINAL PASSWORD: {final_password}\") \n    return 0\n\nif __name__ == \"__main__\":\n    main()"
    }
]